# Puppet CI Resources

classes:
  - nsidc_jenkins
  - nsidc_nfs

# NFS Mounts
nsidc_nfs::sharemounts:
  /share/sw/packages:
    project: sw
    share: packages

# Jenkins Plugins
nsidc_jenkins::plugins:
  git: {}
  git-client: {}
  git-parameter: {}
  scm-api: {}
  credentials: {}
  ssh-credentials: {}
  greenballs: {}
  jobConfigHistory: {}
  mailer: {}
  instant-messaging: {}
  jabber: {}
  ansicolor: {}

# Jenkins Jobs
nsidc_jenkins::jobs:
  # clone the project into the shared workspace
  "%{hiera('project')}_1_Checkout_Project":
    git:
      repo: "%{hiera('gitrepo')}"
      poll_scm: true
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_2_Configure_System"

  # use puppet to install system dependencies, such as Bundler
  "%{hiera('project')}_2_Configure_System":
    command: |
      cd puppet
      librarian-puppet clean
      librarian-puppet update
      cd -

      # with the --detailed-exitcodes flag, exit code of 2 means that changes
      # were made, i.e., puppet did stuff to your system like it's supposed to
      #
      # https://docs.puppetlabs.com/references/3.4.latest/man/agent.html
      bash -c "sudo puppet apply --environment=ci --debug --verbose --detailed-exitcodes --modulepath=./puppet/modules --hiera_config=./puppet/hiera.yaml ./puppet/site.pp; puppet_exit=\$?; echo puppet exit code = \$puppet_exit; if [ \"\$puppet_exit\" = \"2\" ]; then exit 0; else exit \$puppet_exit; fi"

      # Because running `puppet apply` modifies the config.xml for each job
      # defined in ci.yaml, Jenkins has trouble triggering the next job through
      # normal methods (ie, using the trigger_job param), but we can use the
      # Jenkins API to trigger the next job with curl. Just make sure the name
      # of the job in the curl command is correct:
      echo "Triggering a new build of %{hiera('project')}_3_Install_Dependencies"
      curl localhost:8080/job/%{hiera('project')_3_Install_Dependencies}/build
    workspace: /var/lib/jenkins/workspace

  "%{hiera('project')}_3_Install_Dependencies":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_4_Check_Syntax"

  "%{hiera('project')}_4_Check_Syntax":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_5_Run_Unit_Tests"

  "%{hiera('project')}_5_Run_Unit_Tests":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_6_Run_Integration_Tests"

  "%{hiera('project')}_6_Run_Integration_Tests":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_7_Build_Snapshot"

  "%{hiera('project')}_7_Build_Snapshot":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_8_Publish_Snapshot"

  "%{hiera('project')}_8_Publish_Snapshot":
    command:
    workspace: /var/lib/jenkins/workspace

  # If your project builds a package, these jobs provide a template for the
  # release pipeline for your package. Just replace the commented-out rake
  # commands with your own project's task runner.
  "%{hiera('project')}_Release_1_Bump_Version":
    parameters:
      - type: choice
        name: version_type
        choices:
        - patch
        - minor
        - major
    command: # echo $version_type
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_Release_2_Tag"

  "%{hiera('project')}_Release_2_Tag":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_Release_3_Build_Release_Package"

  "%{hiera('project')}_Release_3_Build_Release_Package":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_Release_4_Publish_Release_Package"

  "%{hiera('project')}_Release_4_Publish_Release_Package":
    command:
    workspace: /var/lib/jenkins/workspace
    trigger_job: "%{hiera('project')}_Release_5_Push_to_Git"

  "%{hiera('project')}_Release_5_Push_to_Git":
    command:
    workspace: /var/lib/jenkins/workspace


  "%{hiera('project')}_Destroy_Non_Production_Deployed_VMs":
    description: |
      Clean up non-production VMs that are not needed while the project is not
      in development.
    parameters:
      - type: boolean
        name: integration
        description: destroy the machine deployed to integration
        default: true

      - type: boolean
        name: qa
        description: destroy the machine deployed to qa
        default: true

      - type: boolean
        name: staging
        description: destroy the machine deployed to staging
        default: true

    command: |
      project=%{hiera('project')}

      hijack_and_destroy () {
        vagrant nsidc hijack --env=$1 --project=$project && vagrant nsidc destroy --env=$1 --project=$project || true
      }

      if $integration; then
        hijack_and_destroy integration
      fi

      if $qa; then
        hijack_and_destroy qa
      fi

      if $staging; then
        hijack_and_destroy staging
      fi
